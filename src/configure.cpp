/**
 * Copyright (c) 2014 - 2015 Tolga Cakir <tolga@cevel.net>
 *
 * This source file is part of Game Capture HD Linux driver and is distributed
 * under the MIT License. For more information, see LICENSE file.
 */

#include <vector>
#include <cmath>
#include <iostream>
#include "../gchd.hpp"


//This runs the commands for all configurations up until a point they diverge
//badly in a way we haven't been unable to untangle yet.
void GCHD::configureDevice()
{
	std::vector<unsigned char> version;
	readVersion( version );
	std::cerr << "Hardware revision is " << version.data() << std::endl;

	//register is named BANKSEL from script files.
	write_config<uint16_t>(BANKSEL, 0x0000);

	//Get what is enabled in case we aren't in boot state, we may need to disable
	savedEnableStateRegister_ = read_config<uint16_t>(MAIL_SEND_ENABLE_REGISTER_STATE);

	//Okay, when we first read SCMD_STATE_READBACK_REGISTER
	//To get our current state, it actually TRIGGERS a state change.
	//but only in the case that the current state
	//(as read from SCMD_STATE_READBACK_REGISTER)
	//is already 0.
	uint16_t state;
	if( deviceType_ == DeviceType::GameCaptureHD )
	{
		//Since currentState and nextState are set to 0,
		//This will error out without waiting for the state
		//change to complete if we are in another state
		//which means the flash is loaded.
		//The error will be signified by state != 0
		//Otherwise it will do the transition.
		state=completeStateChange(0x0000, 0x0000);
	}
	else if( deviceType_ == DeviceType::GameCaptureHDNew )
	{
		//We can't use completeStateChange for HDNew,
		//as the read triggers an interrupt, which
		//the normal completeStateChange code doesn't handle.
		bool changed;
		state=read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER);
		state &= 0x1f; //Ignore any other bits other than the ones we care about.

		if( state == 0x0000 )
		{
			interruptPend();
			do
			{
				uint16_t completion=read_config<uint16_t>(SCMD_STATE_CHANGE_COMPLETE);
				changed = (completion & 0x4)>0; //Check appropriate bit
			} while (!changed);

			//Reset sticky bit/acknowledge.
			write_config<uint16_t>(SCMD_STATE_CHANGE_COMPLETE, 0x0004);
		}
	}
	if( state == 0x0000) //We have to load the flash
	{
		// load "idle" firmware
		dlfirm(firmwareIdle_.c_str());

		//no idea what this does.
		write_config<uint16_t>(0xbc, 0x0900, 0x0070, 0x0004);

		savedEnableStateRegister_= read_config<uint16_t>(MAIL_SEND_ENABLE_REGISTER_STATE);
		savedEnableRegister_= read_config<uint16_t>(ENABLE_REGISTER);

		//Not sure what any of this is done for, but it appears we read 2 banks
		// of things
		//that are identical.
		read_config(0xbc, 0x0000, 0x0010, 2); //EXPECTED=0x20, 0x13
		read_config(0xbc, 0x0000, 0x0012, 2); //EXPECTED=0x12, 0x10
		read_config(0xbc, 0x0000, 0x0014, 2); //EXPECTED=0x18, 0x80
		read_config(0xbc, 0x0000, 0x0016, 2); //EXPECTED=0x20, 0x30
		read_config(0xbc, 0x0000, 0x0018, 2); //EXPECTED=0x20, 0x13
		read_config(0xbc, 0x0000, 0x001a, 2); //EXPECTED=0x12, 0x10
		read_config(0xbc, 0x0000, 0x001c, 2); //EXPECTED=0x18, 0x80
		read_config(0xbc, 0x0000, 0x001e, 2); //EXPECTED=0x20, 0x30
	}
	else
	{
		/* Oh, we were already up. Reset to known state, and flash
	 * doesn't need to be loaded
	 */
		stateConfirmedScmd( SCMD_RESET, 0x00, 0x0000 );
	}
	stateConfirmedScmd( SCMD_IDLE, 0x00, 0x0000 );

	specialDetectMask_ = 0xffff; //We are going to use this to auto-detect what
	//type of signal is incoming.

	//Confirm that we are up
	mailWrite( 0x33, VC{0xab, 0xa9, 0x0f, 0xa4, 0x55} );
	mailRead( 0x33, 3 ); //EXPECTED {0x33, 0x44, 0x55}

	std::vector<unsigned char> input=std::vector<unsigned char>(0);

	bool loopDone=false;
	uint32_t deviceModeMagic;
	bool firstTime=true;

	while(!loopDone)
	{
		mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x55} );
		input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */

		//Get magic number requested from port 0x33 last state.
		//Convert 3 bytes into one 24 bit number.
		deviceModeMagic=
				Utility::debyteify<uint32_t>(input.data(), 3);


		switch( deviceModeMagic ) {
			case 0x334455: //First device magic number we read back,
				//We loop on this till it transitions to 0x27f97b
			{
				//TURN ON PROCESSOR
				sendEnableState();
				enableAnalogInput();
				doEnable( EB_FIRMWARE_PROCESSOR, EB_FIRMWARE_PROCESSOR );
			}
				break;

			case 0x27f97b:
			{
				if (firstTime ) {
					bool hdmiSignalFound = (( specialDetectMask_ >> 3) & 1) != 0;
					unsigned cableType = specialDetectMask_  & 3;
					bool signalFound;

					if( cableType == 0 ) {
						signalFound=hdmiSignalFound;
					} else {
						signalFound=true;
					}

					InputSource autodetectInputSource = InputSource::Unknown;
					if( !signalFound ) {
						autodetectInputSource=InputSource::HDMI;
					} else {
						switch(cableType)
						{
							case 3:
								autodetectInputSource=InputSource::Composite;
								break;
							case 2:
								autodetectInputSource=InputSource::Component;
								break;
							case 0:
								autodetectInputSource=InputSource::HDMI;
							case 1:
								autodetectInputSource=InputSource::SVideo;
								break;
							default:
								if( passedInputSettings_.getSource() == InputSource::Unknown ) {
									throw runtime_error("Unable to detect input source.");
								}
								break;
						}
					}
					bool forced=false;
					if( passedInputSettings_.getSource() == InputSource::Unknown ) {
						currentInputSettings_.setSource( autodetectInputSource );
					} else {
						forced=true;
						currentInputSettings_.setSource( passedInputSettings_.getSource() );
					}
					if ((!signalFound) && (!forced)) {
						std::cerr << "No signal found. Defaulting to HDMI." << std::endl;
						forced=true;
					}
					switch( currentInputSettings_.getSource() ) {
						case InputSource::HDMI:
							std::cerr << "HDMI input ";
							break;
						case InputSource::Component:
							std::cerr << "Component input ";
							break;
						case InputSource::Composite:
							std::cerr << "Composite input ";
							break;
						case InputSource::Unknown:
							throw std::logic_error("Failed to set source.");
							break;
					}
					if( forced ) {
						std::cerr << "forced." << std::endl;;
					} else {
						std::cerr << "found?" << std::endl;
					}
				}

				//THis number is the 2nd number we read
				//back, and we end up repeating this after
				//main_initialize until the initialization is done.
				//Then we transition to 0x78e045, and we then come back here.
				enableAnalogInput();

				if( firstTime )  {

					transcoderDefaultsInitialize();         //just came back from here.
					scmd(SCMD_INIT, 0x00, 0x0000);

					dlfirm(firmwareEnc_.c_str());

					firstTime=false;
					read_config<uint16_t>(0xbc, 0x0000, 0x0010); //EXPECTED=0x2013
					read_config<uint16_t>(0xbc, 0x0000, 0x0012); //EXPECTED=0x1210
					read_config<uint16_t>(0xbc, 0x0000, 0x0014); //EXPECTED=0x1880
					read_config<uint16_t>(0xbc, 0x0000, 0x0016); //EXPECTED=0x2030
					//Note that it is possible after firmware load for us to fallback
					//temporarily to 0x334455 on some devices.

				} else {
					loopDone=true;
				}

			}
				break;
		}
	}
	for (int i=0; i<5; ++i) {
		mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x5b} );
		input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
		enableAnalogInput();
		deviceModeMagic=
				Utility::debyteify<uint32_t>(input.data(), 3);
		//In one known case a user has reported different values
		//then our captured 0x78e045 coming back here,
		//kueller reported on gitter that he gets back 0x7bec47
		//so this is less than ideal, but gonna use a mask to
		//catch both values, and put in terminating loop regardless.
		if( (deviceModeMagic & 0xf8f0f0) == 0x78e040 ) {
			break;
		}
	}
	doEnable( EB_ENCODER_ENABLE, EB_ENCODER_ENABLE );

	//We can go back to 0x334455 after we turn on EB_ENCODER_ENABLE in some cases,
	//Wait till we are 0x27f97b
	do
	{
		mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x55} );
		input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
		deviceModeMagic=
				Utility::debyteify<uint32_t>(input.data(), 3);
	} while( deviceModeMagic != 0x27f97b );

	mailWrite( 0x33, VC{0x28, 0x28} );
	mailWrite( 0x33, VC{0x29, 0x89, 0x5b} );
	mailRead( 0x33, 1 ); //EXPECTED {0x91}
	mailWrite( 0x33, VC{0xdd, 0xce, 0x3f, 0xb2} );
	mailRead( 0x33, 2 ); //EXPECTED {0xda, 0x67}

	doEnable( EB_ENCODER_TRIGGER, EB_ENCODER_TRIGGER ); //Turn on trigger bit
	do
	{
		mailWrite( 0x33, VC{0x43, 0x23, 0x84} );
		input=mailRead( 0x33, 1 ); //EXPECTED {0xf7}
	} while(input[0] != 0xf7);
	doEnable( EB_ENCODER_TRIGGER, 0 ); //Turn off trigger bit

	mailWrite( 0x33, VC{0x89, 0x89, 0xfb} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}

	//Potential subroutine
	{
		mailWrite( 0x44, VC{0x02, 0xc9} );
		mailWrite( 0x44, VC{0x14, 0xd2} );
		mailWrite( 0x44, VC{0x3c, 0x6b} );
		mailWrite( 0x33, VC{0x89, 0x89, 0xfa} );
		mailRead( 0x33, 1 ); //EXPECTED {0xed}
	}
	mailWrite( 0x33, VC{0x89, 0x89, 0xca} );
	mailRead( 0x33, 1 ); //EXPECTED {0xee}
	mailWrite( 0x33, VC{0x89, 0x89, 0xe7} );
	mailRead( 0x33, 1 ); //EXPECTED {0x49}
	mailWrite( 0x44, VC{0x03, 0x2a} );
	mailWrite( 0x44, VC{0x05, 0x89} );

	//This is an educated guess right now as to why it
	//set one way or the other. Currently it presumed
	//that it doesn't really matter much because
	//the old configure scripts didn't seem to match
	//captures that I've seen.
	bool analog = currentInputSettings_.getSource() != InputSource::HDMI;
	if( analog ) {
		mailWrite( 0x44, VC{0x08, 0x91} );
		mailWrite( 0x44, VC{0x09, 0xa8} );
	} else {
		mailWrite( 0x44, VC{0x08, 0x9b} );
		mailWrite( 0x44, VC{0x09, 0x7a} );
	}
	mailWrite( 0x44, VC{0x19, 0xde} );
	mailWrite( 0x44, VC{0x1a, 0x87} );
	mailWrite( 0x44, VC{0x1b, 0x88} );
	mailWrite( 0x44, VC{0x29, 0x8b} );
	mailWrite( 0x44, VC{0x2d, 0x8f} );
	mailWrite( 0x44, VC{0x4c, 0x89} );
	mailWrite( 0x44, VC{0x55, 0x88} );
	mailWrite( 0x44, VC{0x6b, 0xae} );
	mailWrite( 0x44, VC{0x6c, 0xbe} );
	mailWrite( 0x44, VC{0x6d, 0x78} );
	mailWrite( 0x44, VC{0x6e, 0xa0} );
	mailWrite( 0x44, VC{0x06, 0x08} );

	//Potential subroutine
	{
		mailWrite( 0x44, VC{0x02, 0xc9} );
		mailWrite( 0x44, VC{0x14, 0xd2} );
		mailWrite( 0x44, VC{0x3c, 0x6b} );
		mailWrite( 0x33, VC{0x89, 0x89, 0xfa} );
		mailRead( 0x33, 1 ); //EXPECTED {0xfd}
	}
	mailWrite( 0x44, VC{0x28, 0x88} );
	mailWrite( 0x44, VC{0x10, 0x88} );
	mailWrite( 0x44, VC{0x11, 0xd4} );
	mailWrite( 0x44, VC{0x12, 0xd0} );
	mailWrite( 0x44, VC{0x13, 0x08} );
	mailWrite( 0x44, VC{0x14, 0x08} );
	mailWrite( 0x44, VC{0x15, 0x88} );
	mailWrite( 0x33, VC{0x94, 0x47, 0xf9} );
	mailWrite( 0x33, VC{0x94, 0x40, 0xf3} );
	mailWrite( 0x33, VC{0x94, 0x43, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x4e, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x4f, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x48, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x49, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x58, 0x77} );
	mailWrite( 0x33, VC{0x94, 0x40, 0xf1} );
	mailWrite( 0x33, VC{0x94, 0x4d, 0xf5} );
	mailWrite( 0x33, VC{0x94, 0x4a, 0xaf} );
	mailWrite( 0x33, VC{0x94, 0x4b, 0xaf} );
	mailWrite( 0x33, VC{0x94, 0x5c, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x46, 0xd7} );

	readDevice0x9DCD(0x88); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0xb7, 0xce} );
	mailWrite( 0x4e, VC{0x41, 0xa3} );
	mailWrite( 0x4e, VC{0xb8, 0xcc} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x00, 0xcd} );
	mailWrite( 0x4e, VC{0x0f, 0xce} );
	mailWrite( 0x4e, VC{0x16, 0xfc} );
	mailWrite( 0x4e, VC{0x17, 0xcc} );
	mailWrite( 0x4e, VC{0x18, 0xcc} );
	mailWrite( 0x4e, VC{0x19, 0xcc} );
	mailWrite( 0x4e, VC{0x1a, 0x9c} );
	readDevice0x9DCD(0x15); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x2a, 0xcb} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb3
	mailWrite( 0x4e, VC{0x00, 0xce} );
	mailWrite( 0x4e, VC{0x08, 0xcf} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb0
	mailWrite( 0x4e, VC{0x00, 0xcd} );
	if ( deviceType_ == DeviceType::GameCaptureHDNew )
	{
		mailWrite( 0x4e, VC{0x24, 0x8c} );
	} else {
		mailWrite( 0x4e, VC{0x24, 0x8d} );
	}
	mailWrite( 0x4e, VC{0x25, 0xcc} );
	mailWrite( 0x4e, VC{0x30, 0x4c} );
	mailWrite( 0x4e, VC{0x31, 0xcc} );
	mailWrite( 0x4e, VC{0x32, 0xcc} );
	mailWrite( 0x4e, VC{0x25, 0xcc} );
	mailWrite( 0x4e, VC{0x26, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb3
	mailWrite( 0x4e, VC{0x00, 0xcc} );
	mailWrite( 0x4e, VC{0xb0, 0xe8} );
	readDevice0x9DCD(0x91); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0xae, 0xc8} );
	mailWrite( 0x4e, VC{0xb1, 0x0c} );
	mailWrite( 0x4e, VC{0xb2, 0xcc} );
	mailWrite( 0x4e, VC{0xb3, 0xcc} );
	mailWrite( 0x4e, VC{0xb4, 0x99} );
	readDevice0x9DCD(0x8b); //EXPECTED 0xe7
	mailWrite( 0x4e, VC{0xb4, 0x98} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x00, 0xce} );
	mailWrite( 0x4e, VC{0x01, 0xad} );
	mailWrite( 0x4e, VC{0x02, 0x39} );
	readDevice0x9DCD(0x3c); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x03, 0xce} );
	mailWrite( 0x4e, VC{0x04, 0xcd} );
	mailWrite( 0x4e, VC{0x05, 0xcc} );
	mailWrite( 0x4e, VC{0x06, 0xc4} );
	mailWrite( 0x4e, VC{0x1c, 0xd6} );
	mailWrite( 0x4e, VC{0x1d, 0xcc} );
	mailWrite( 0x4e, VC{0x1e, 0xcc} );
	mailWrite( 0x4e, VC{0x1f, 0xcc} );
	readDevice0x9DCD(0x1a); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x25, 0x6e} );
	readDevice0x9DCD(0x3d); //EXPECTED 0x47
	mailWrite( 0x4e, VC{0x02, 0x39} );
	readDevice0x9DCD(0x38); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x07, 0xc8} );
	mailWrite( 0x4e, VC{0x17, 0x0c} );
	mailWrite( 0x4e, VC{0x19, 0x33} );
	mailWrite( 0x4e, VC{0x1a, 0x33} );
	mailWrite( 0x4e, VC{0x1b, 0x30} );
	mailWrite( 0x4e, VC{0x20, 0xcc} );
	readDevice0x9DCD(0x1e); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x21, 0xcc} );
	mailWrite( 0x4e, VC{0x22, 0xea} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	readDevice0x9DCD(0x11); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x2e, 0x6d} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xfa} );
	mailRead( 0x33, 1 ); //EXPECTED {0xa4}
	mailWrite( 0x33, VC{0x99, 0x89, 0xf9} );
	mailRead( 0x33, 1 ); //EXPECTED {0x7f}
	mailWrite( 0x33, VC{0x99, 0x89, 0xf8} );
	mailRead( 0x33, 1 ); //EXPECTED {0x78}
	mailWrite( 0x33, VC{0x99, 0x89, 0xfe} );
	mailRead( 0x33, 1 ); //EXPECTED {0x0e}
	mailWrite( 0x4c, VC{0x05, 0x88} );
	mailWrite( 0x4c, VC{0x04, 0xb5} );
	mailWrite( 0x4c, VC{0x04, 0x95} );
	mailWrite( 0x4c, VC{0x61, 0xb8} );
	mailWrite( 0x4c, VC{0x09, 0x3a} );
	mailWrite( 0x4c, VC{0x0a, 0x70} );
	mailWrite( 0x4c, VC{0x0b, 0xbf} );
	mailWrite( 0x4c, VC{0xc9, 0x88} );
	mailWrite( 0x4c, VC{0xca, 0x88} );
	mailWrite( 0x4c, VC{0xcb, 0x88} );
	mailWrite( 0x4c, VC{0xcc, 0x88} );
	mailWrite( 0x4c, VC{0xcd, 0x88} );
	mailWrite( 0x4c, VC{0xce, 0x88} );
	mailWrite( 0x4c, VC{0xcf, 0x88} );
	mailWrite( 0x4c, VC{0xd0, 0x88} );

	if ( deviceType_ == DeviceType::GameCaptureHDNew )
	{
		mailWrite( 0x33, VC{0x21, 0x01, 0x72} );
		mailRead( 0x33, 1 ); //EXPECTED {0xf4}
		mailWrite( 0x33, VC{0x20, 0x02, 0x63} );
		mailWrite( 0x33, VC{0x20, 0x03, 0x63} );
		mailWrite( 0x33, VC{0x20, 0x04, 0x77} );
		mailWrite( 0x33, VC{0x20, 0x05, 0x73} );
		mailWrite( 0x33, VC{0x20, 0x06, 0x73} );
		mailWrite( 0x33, VC{0x20, 0x07, 0x33} );
		mailWrite( 0x33, VC{0x20, 0x08, 0x31} );
		mailWrite( 0x33, VC{0x20, 0x09, 0x33} );
		mailWrite( 0x33, VC{0x20, 0x0a, 0x57} );
		mailWrite( 0x33, VC{0x20, 0x0b, 0x7b} );
		mailWrite( 0x33, VC{0x20, 0x0c, 0xf7} );
		mailWrite( 0x33, VC{0x20, 0x0d, 0xf7} );
		mailWrite( 0x33, VC{0x20, 0x0e, 0x73} );
		mailWrite( 0x33, VC{0x20, 0x0f, 0x73} );
	}
	mailWrite( 0x33, VC{0xaa, 0x8f, 0x3b} );


	//----------------------------------------------------------

	//The next set of writes and the laster 56 byte reads
	//are not understood at  all.
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xfb, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x33, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x6b, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xa3, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xdb, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x13, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x4b, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x83, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xbb, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xf3, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x2b, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x63, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x9b, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xd3, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x0b, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x43, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x7b, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xb3, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xeb, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x23, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x5b, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x93, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xcb, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xfb, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x33, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x6b, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xa3, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xdb, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x13, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x4b, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x83, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xbb, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xf3, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x2b, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x63, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x9b, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xd3, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x0b, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x43, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x7b, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xb3, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xeb, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x23, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x5b, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x93, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xcb, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0xa2, 0x3e, 0xb4, 0xfb, 0x79} );


	mailRead( 0x33, 8 ); //EXPECTED {0xe9, 0x5c, 0xcf, 0x42, 0xb5, 0x28, 0x9b, 0x0e}
	mailWrite( 0x33, VC{0xaa, 0x8d, 0x35} );
	for (int i=0; i<5; ++i) {
		mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x5b} );
		input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
		enableAnalogInput();
		deviceModeMagic=
				Utility::debyteify<uint32_t>(input.data(), 3);
		//In one known case a user has reported different values
		//then our captured 0x78e045 coming back here,
		//kueller reported on gitter that he gets back 0x7bec47,
		//(but only verified for earlier incarnation of this loop)
		//so this patch is less than ideal, but gonna use a mask to
		//catch both values, and put in terminating loop regardless.
		if( (deviceModeMagic & 0xf8f0f0) == 0x78e040 ) {
			break;
		}
	}

	transcoderSetup( currentInputSettings_, currentTranscoderSettings_ );
	transcoderOutputEnable(true);

	analog = currentInputSettings_.getSource() != InputSource::HDMI;
	bool composite = currentInputSettings_.getSource() == InputSource::Composite;

	scmd(SCMD_INIT, 0xa0, 0x0000);
	if( !composite )  {
		mailWrite( 0x44, VC{0x06, 0x86} );
	} else {
		mailWrite( 0x33, VC{0x89, 0x89, 0xfd} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6e}
	}
	mailWrite( 0x33, VC{0x89, 0x89, 0xf8} );
	mailRead( 0x33, 1 ); //EXPECTED {0xcc}

	if( !composite ) {
		mailWrite( 0x44, VC{0x03, 0x2f} );
	} else {
		mailWrite( 0x44, VC{0x03, 0x28} );
	}
	readDevice0x9DCD(0x3f); //EXPECTED 0xb0
	mailWrite( 0x4e, VC{0x00, 0xcc} );
	if( !composite ) {
		mailWrite( 0x4e, VC{0xb3, 0xcc} );
	} else {
		mailWrite( 0x4e, VC{0xb3, 0x33} );
	}
	readDevice0x9DCD(0x3f); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x00, 0xce} );
	if( !composite ) {
		mailWrite( 0x4e, VC{0x27, 0xcc} );
	} else {
		mailWrite( 0x4e, VC{0x27, 0x33} );
		readDevice0x9DCD(0x3f);
		mailWrite( 0x4e, VC{0x00, 0xcc} );
		readDevice0x9DCD(0x6e);
		mailWrite( 0x4e, VC{0x51, 0xcc} );
	}
	doEnable( EB_COMPOSITE_MUX, composite ? EB_COMPOSITE_MUX: 0);
	doEnable( EB_ANALOG_INPUT, analog ? EB_ANALOG_INPUT: 0);
	doEnable( EB_ANALOG_MUX, analog ? EB_ANALOG_MUX:0);


	switch (currentInputSettings_.getSource())
	{
		case InputSource::HDMI:
			configureHDMI();
			break;
		case InputSource::Component:
			configureComponent();
			break;
		case InputSource::Composite:
			configureComposite();
			break;
		case InputSource::Unknown:
		default:
			throw runtime_error("Unknown input source not currently allowed.");
			break;
	}
}


void GCHD::uninitDevice()
{
	uint16_t state=read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER) & 0x1f;
	if(( state == SCMD_STATE_START ) || ( state==SCMD_STATE_NULL )) {
		stopStream( true );
	}
	//0x12 means already unininitialized (SCMD_RESET with mode=0x1),
	//0x10 means already unininitialized (SCMD_RESET with mode=0x0).
	//ox00 means never initialized.
	if(( state != 0x12 ) && (state != 0x00) && (state != 0x10)) {
		//Mystery subroutine, done after an SCMD_INIT too.
		{
			mailWrite( 0x44, VC{0x06, 0x86} );
			mailWrite( 0x33, VC{0x89, 0x89, 0xf8} );
			mailRead( 0x33, 1 ); //EXPECTED {0xc9}
			mailWrite( 0x44, VC{0x03, 0x2f} );
		}
		//No idea what this is, but presumably selects proper bank.
		//Seems to be always done before configuring the transcoder with
		//sparam commands.
		write_config<uint16_t>(BANKSEL, 0x0000);
		readEnableState(); //EXPECTED 0xd39e HD NEW. 0x31e on HD

		read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER); //seems no reason for this read..
		transcoderOutputEnable( false );

		scmd(SCMD_INIT, 0xa0, 0x0000);
		clearEnableState();

		//This command appears to do nothing, it appears to be a doEnable
		//for a bit that we can't identify, that isn't configured
		//in any of our test cases.
		doEnable(EB_FIRMWARE_PROCESSOR, 0x0);

		stateConfirmedScmd( SCMD_IDLE, 0x00, 0x0000 );
		stateConfirmedScmd( SCMD_RESET, 0x01, 0x0000 );
	}
}

void GCHD::configureColorSpace()
{
	//Only reason this is included here is because it clearly comes before
	//color space configuration in the original driver thread.
	if (currentInputSettings_.getSource() == InputSource::Component) {
		mailWrite( 0x4e, VC{0x0b, 0x4c} );
		mailWrite( 0x4e, VC{0x0c, 0x4c} );
		mailWrite( 0x4e, VC{0x0d, 0x4c} );
		mailWrite( 0x4e, VC{0x08, 0x4c} );
		mailWrite( 0x4e, VC{0x09, 0x4c} );
		mailWrite( 0x4e, VC{0x0a, 0x4c} );
		mailWrite( 0x4e, VC{0x1e, 0x98} );
		mailWrite( 0x4e, VC{0x1f, 0xc9} );
	}

	if( currentInputSettings_.getColorSpace()==ColorSpace::YUV ) {
		//Set up color space.
		mailWrite( 0x4e, VC{0x92, 0xaa} );
		mailWrite( 0x4e, VC{0x93, 0xdc} );
		mailWrite( 0x4e, VC{0x94, 0xcc} );
		mailWrite( 0x4e, VC{0x95, 0xcc} );
		mailWrite( 0x4e, VC{0x96, 0xcc} );
		mailWrite( 0x4e, VC{0x97, 0xcc} );
		mailWrite( 0x4e, VC{0x98, 0xcc} );
		mailWrite( 0x4e, VC{0x99, 0xcc} );
		mailWrite( 0x4e, VC{0x9a, 0xcc} );
		mailWrite( 0x4e, VC{0x9b, 0xdc} );
		mailWrite( 0x4e, VC{0x9c, 0xcc} );
		mailWrite( 0x4e, VC{0x9d, 0xcc} );
		mailWrite( 0x4e, VC{0x9e, 0xcc} );
		mailWrite( 0x4e, VC{0x9f, 0xcc} );
		mailWrite( 0x4e, VC{0xa0, 0xcc} );
		mailWrite( 0x4e, VC{0xa1, 0xcc} );
		mailWrite( 0x4e, VC{0xa2, 0xcc} );
		mailWrite( 0x4e, VC{0xa3, 0xdc} );
		mailWrite( 0x4e, VC{0xa4, 0xcc} );
		mailWrite( 0x4e, VC{0xa5, 0xec} );
		mailWrite( 0x4e, VC{0xa6, 0xcc} );
		mailWrite( 0x4e, VC{0xa7, 0xc8} );
		mailWrite( 0x4e, VC{0xa8, 0xcd} );
		mailWrite( 0x4e, VC{0xa9, 0xec} );
		mailWrite( 0x4e, VC{0xaa, 0xcc} );
	} else {
		mailWrite( 0x4e, VC{0x92, 0x8c} );
		mailWrite( 0x4e, VC{0x93, 0xcb} );
		mailWrite( 0x4e, VC{0x94, 0xca} );
		mailWrite( 0x4e, VC{0x95, 0xce} );
		mailWrite( 0x4e, VC{0x96, 0x22} );
		mailWrite( 0x4e, VC{0x97, 0xb2} );
		mailWrite( 0x4e, VC{0x98, 0xae} );
		mailWrite( 0x4e, VC{0x99, 0xb5} );
		mailWrite( 0x4e, VC{0x9a, 0x52} );
		mailWrite( 0x4e, VC{0x9b, 0xc5} );
		mailWrite( 0x4e, VC{0x9c, 0x1f} );
		mailWrite( 0x4e, VC{0x9d, 0xb6} );
		mailWrite( 0x4e, VC{0x9e, 0x54} );
		mailWrite( 0x4e, VC{0x9f, 0xb3} );
		mailWrite( 0x4e, VC{0xa0, 0x90} );
		mailWrite( 0x4e, VC{0xa1, 0xcc} );
		mailWrite( 0x4e, VC{0xa2, 0x32} );
		mailWrite( 0x4e, VC{0xa3, 0xcb} );
		mailWrite( 0x4e, VC{0xa4, 0xca} );
		mailWrite( 0x4e, VC{0xa5, 0xec} );
		mailWrite( 0x4e, VC{0xa6, 0xcc} );
		mailWrite( 0x4e, VC{0xa7, 0xc8} );
		mailWrite( 0x4e, VC{0xa8, 0xcd} );
		mailWrite( 0x4e, VC{0xa9, 0xec} );
		mailWrite( 0x4e, VC{0xaa, 0xcc} );
	}

	//Only reason this is included here is because it clearly comes next
	//in the original driver thread.
	if (currentInputSettings_.getSource() == InputSource::Component) {
		switch(currentInputSettings_.getResolution()) {
			case Resolution::HD1080:
				mailWrite( 0x4e, VC{0xb2, 0xcc} );
				mailWrite( 0x4e, VC{0xb5, 0xc4} );

				if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
					mailWrite( 0x4e, VC{0x03, 0x0c} );
				} else { //1080p30
					mailWrite( 0x4e, VC{0x03, 0x04} );
				}
				break;
			case Resolution::HD720:
				mailWrite( 0x4e, VC{0xb2, 0xcc} );
				mailWrite( 0x4e, VC{0xb5, 0xc4} );
				mailWrite( 0x4e, VC{0x03, 0x8c} );
				break;
			case Resolution::PAL: //Same setup here.
			case Resolution::NTSC:
				mailWrite( 0x4e, VC{0xb2, 0xcf} );
				mailWrite( 0x4e, VC{0xb5, 0xc4} );

				if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
					mailWrite( 0x4e, VC{0x03, 0x8c} );
				} else {
					mailWrite( 0x4e, VC{0x03, 0x84} );
				}
				break;
			default:
				throw runtime_error( "Current selected video mode is not a supported mode.");
				break;
		}
	}
}

void GCHD::configureSetupSubblock()
{
	mailWrite( 0x33, VC{0x99, 0x89, 0x8b} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}

	switch(currentInputSettings_.getSource())
	{
		case InputSource::HDMI:
			mailWrite( 0x4c, VC{0x70, 0xc8} );
			mailWrite( 0x4c, VC{0x90, 0x88} );
			mailWrite( 0x4c, VC{0x91, 0x77} );
			mailWrite( 0x4c, VC{0x92, 0x77} );
			mailWrite( 0x4c, VC{0x93, 0x77} );
			mailWrite( 0x4c, VC{0x94, 0x77} );
			mailWrite( 0x4c, VC{0x95, 0x77} );
			mailWrite( 0x4c, VC{0x96, 0x77} );
			mailWrite( 0x4c, VC{0x97, 0x77} );
			mailWrite( 0x4c, VC{0x98, 0x77} );
			mailWrite( 0x4c, VC{0x99, 0x77} );
			mailWrite( 0x4c, VC{0x9a, 0x77} );
			mailWrite( 0x4c, VC{0x9b, 0x77} );
			mailWrite( 0x4c, VC{0x9c, 0x77} );
			mailWrite( 0x4c, VC{0x9d, 0x77} );
			mailWrite( 0x4c, VC{0x9e, 0x77} );
			mailWrite( 0x4c, VC{0x9f, 0x77} );
			mailWrite( 0x4c, VC{0xa0, 0x77} );
			mailWrite( 0x4c, VC{0xa1, 0x77} );
			mailWrite( 0x4c, VC{0xa2, 0x77} );
			mailWrite( 0x4c, VC{0xa3, 0x77} );
			break;

			//576i and 480i have the same setup on Component and Composite
		case InputSource::Component:
		case InputSource::Composite:
			switch(currentInputSettings_.getResolution())
			{
				case Resolution::HD1080:
					if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
						mailWrite( 0x4c, VC{0x70, 0xc0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0xae} );
						mailWrite( 0x4c, VC{0x91, 0xc2} );
						mailWrite( 0x4c, VC{0x95, 0xde} );
						mailWrite( 0x4c, VC{0x96, 0x0a} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x8a} );
						mailWrite( 0x4c, VC{0xa1, 0xf8} );
						mailWrite( 0x4c, VC{0xa2, 0xbc} );
						mailWrite( 0x4c, VC{0xa3, 0x1a} );
					} else { //Assuming HD1080p30
						mailWrite( 0x4c, VC{0x70, 0xc0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0x7e} );
						mailWrite( 0x4c, VC{0x91, 0x77} );
						mailWrite( 0x4c, VC{0x95, 0xde} );
						mailWrite( 0x4c, VC{0x96, 0x0a} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x8c} );
						mailWrite( 0x4c, VC{0xa1, 0x18} );
						mailWrite( 0x4c, VC{0xa2, 0x77} );
						mailWrite( 0x4c, VC{0xa3, 0x77} );
					}
					break;
				case Resolution::HD720:
					mailWrite( 0x4c, VC{0x70, 0xc0} );
					mailWrite( 0x4c, VC{0x0f, 0x88} );
					mailWrite( 0x4c, VC{0x90, 0xfe} );
					mailWrite( 0x4c, VC{0x91, 0xbb} );
					mailWrite( 0x4c, VC{0x95, 0xe4} );
					mailWrite( 0x4c, VC{0x96, 0x1c} );
					mailWrite( 0x4c, VC{0x97, 0x88} );
					mailWrite( 0x4c, VC{0xa0, 0x8d} );
					mailWrite( 0x4c, VC{0xa1, 0x28} );
					mailWrite( 0x4c, VC{0xa2, 0x77} );
					mailWrite( 0x4c, VC{0xa3, 0x77} );
					break;
				case Resolution::PAL:
					if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
						mailWrite( 0x4c, VC{0x70, 0xd0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0xd8} );
						mailWrite( 0x4c, VC{0x91, 0xbf} );
						mailWrite( 0x4c, VC{0x95, 0x9d} );
						mailWrite( 0x4c, VC{0x96, 0x1b} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x8a} );
						mailWrite( 0x4c, VC{0xa1, 0xd8} );
						mailWrite( 0x4c, VC{0xa2, 0xb2} );
						mailWrite( 0x4c, VC{0xa3, 0x59} );
					} else {
						mailWrite( 0x4c, VC{0x70, 0xc0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0x28} );
						mailWrite( 0x4c, VC{0x91, 0x93} );
						mailWrite( 0x4c, VC{0x95, 0x82} );
						mailWrite( 0x4c, VC{0x96, 0xc2} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x8d} );
						mailWrite( 0x4c, VC{0xa1, 0x28} );
						mailWrite( 0x4c, VC{0xa2, 0x77} );
						mailWrite( 0x4c, VC{0xa3, 0x77} );
					}
					break;
				case Resolution::NTSC:
					if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
						mailWrite( 0x4c, VC{0x70, 0xd0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0x68} );
						mailWrite( 0x4c, VC{0x91, 0xbf} );
						mailWrite( 0x4c, VC{0x95, 0xab} );
						mailWrite( 0x4c, VC{0x96, 0x17} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x8c} );
						mailWrite( 0x4c, VC{0xa1, 0xf8} );
						mailWrite( 0x4c, VC{0xa2, 0x82} );
						mailWrite( 0x4c, VC{0xa3, 0x59} );
					} else {
						mailWrite( 0x4c, VC{0x70, 0xc0} );
						mailWrite( 0x4c, VC{0x0f, 0x88} );
						mailWrite( 0x4c, VC{0x90, 0x78} );
						mailWrite( 0x4c, VC{0x91, 0xb9} );
						mailWrite( 0x4c, VC{0x95, 0x86} );
						mailWrite( 0x4c, VC{0x96, 0xc4} );
						mailWrite( 0x4c, VC{0x97, 0x88} );
						mailWrite( 0x4c, VC{0xa0, 0x81} );
						mailWrite( 0x4c, VC{0xa1, 0x78} );
						mailWrite( 0x4c, VC{0xa2, 0x77} );
						mailWrite( 0x4c, VC{0xa3, 0x77} );
					}
					break;

				default:
					throw runtime_error( "Current selected video mode is not a supported mode.");
					break;
			}
			break;
		default:
			throw runtime_error( "Unsupported input source.");
			break;
	}
}

void GCHD::configureCommonBlockA()
{
	mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0x88} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32);
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0xa8} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32);
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0xc8} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x2b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0x6f, 0x73, 0x6e, 0x1c, 0x3f, 0xbe, 0x70, 0x4e, 0x00, 0x46, 0x3b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0x6e, 0x6e, 0x6e, 0x93, 0x6e, 0x5c}
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0xe8} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x52, 0x70, 0x3f, 0x7f, 0x6e, 0x64, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x6e, 0x6e, 0x6e, 0x92, 0x6e, 0x3d, 0x17, 0x00, 0x0d, 0x23, 0x0f, 0x1d, 0x1a, 0x0b, 0x1c, 0x64, 0x4e, 0x4e, 0x6f, 0xfa}

	mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0x08} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x6c, 0x6d, 0x72, 0x9f, 0x26, 0xfe, 0x6a, 0x71, 0x6b, 0x7a, 0x7d, 0x6d, 0x7c, 0x4d, 0x67, 0x69, 0x69, 0xed, 0x6f, 0x6e, 0x6e, 0x08, 0x6d, 0x62, 0x6e, 0x7e, 0x6e, 0xee, 0x6f, 0x73, 0xee, 0xbe}
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0x28} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x1c, 0x72, 0x78, 0x4e, 0x7e, 0x42, 0x4b, 0xee, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0xf0, 0x6f, 0x73, 0xee, 0x76, 0x1f, 0x72, 0x78, 0x4e, 0x36, 0x42, 0x4b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0xf0}
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0x48} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x6f, 0x73, 0x6e, 0xd2, 0x3c, 0xbe, 0x70, 0x4e, 0xd6, 0x46, 0x3b, 0x2e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0xe2, 0x64, 0xbe, 0xfe, 0x4e, 0x2e, 0x5f, 0x4e, 0x62, 0x2e, 0x3b, 0x6e, 0xce, 0x34}
	mailWrite( 0x4c, VC{0x15, 0x81} );
	mailWrite( 0x4c, VC{0x65, 0x8a} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0x28} );
	mailWrite( 0x4c, VC{0x12, 0x68} );
	mailWrite( 0x4c, VC{0x13, 0xa8} );
	mailWrite( 0x4c, VC{0x14, 0x88} );
	mailWrite( 0x4c, VC{0x15, 0x8b} );
	pollOn0x9989ED();
	readFrom0x9989EC(32); //EXPECTED {0x6e, 0x6e, 0x6e, 0x76, 0xe2, 0x64, 0xbe, 0xe4, 0x4e, 0x8e, 0x43, 0x7e, 0x7e, 0x50, 0xf8, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x76, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x28}

	if ( deviceType_ == DeviceType::GameCaptureHD ) {
		configureCommonBlockC(); //Think this is just a driver choice to move it to just doing it at the end on newer model
	}
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0x10, 0x89} );
	mailWrite( 0x4c, VC{0x11, 0xfc} );
	mailWrite( 0x4c, VC{0x12, 0xc8} );
	mailWrite( 0x4c, VC{0x13, 0x8b} );
	mailWrite( 0x4c, VC{0x15, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xed} );
	mailRead( 0x33, 1 ); //EXPECTED {0xec}
	mailWrite( 0x33, VC{0x99, 0x8a, 0xbf} );
	mailRead( 0x33, 2 ); //EXPECTED {0x6e, 0xe1}
	mailWrite( 0x33, VC{0x99, 0x89, 0xb8} );
	std::vector<uint8_t> readValue=mailRead( 0x33, 1 );

	mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
	mailRead( 0x33, 1 ); //EXPECTED {0x02}

	mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
	mailRead( 0x33, 1 ); //EXPECTED {0x02}
	mailWrite( 0x33, VC{0x10, 0x00, 0x33} );

	//I have a theory that this is set to ceil( .95 * Theory read point above
	uint8_t setValue=std::ceil(.95 * readValue[0]);
	mailWrite( 0x33, VC{0x10, 0x01, setValue} );
	mailWrite( 0x33, VC{0x10, 0x02, 0x71} );
	mailWrite( 0x33, VC{0x10, 0x03, 0x72} );

	//Not sure if I should subtract 80 to min zero, or
	//just clear the bit. We'll just clear it.
	setValue &= ~0x80;
	mailWrite( 0x33, VC{0x10, 0x01, setValue} );

	//SPECIAL END
	mailWrite( 0x4c, VC{0x04, 0x95} );

	if ( deviceType_ == DeviceType::GameCaptureHD ) {
		mailWrite( 0x4c, VC{0x0f, 0x88} );
		mailWrite( 0x4c, VC{0xc1, 0x89} );
		mailWrite( 0x4c, VC{0xc6, 0x8b} );
	}
}


void GCHD::configureCommonBlockB1( bool mysteryParameter )
{
	mailWrite( 0x33, VC{0x99, 0x89, 0x89} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}
	mailWrite( 0x4c, VC{0x72, 0x88} );
	mailWrite( 0x4c, VC{0xc0, 0x89} );
	mailWrite( 0x4c, VC{0x61, 0x98} );
	mailWrite( 0x4c, VC{0x63, 0x89} );

	//Mystery setting difference.
	if( mysteryParameter ) {
		mailWrite( 0x4c, VC{0x64, 0xde} );
	} else {
		mailWrite( 0x4c, VC{0x64, 0x96} );
	}

	mailWrite( 0x4c, VC{0x65, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x73}
	mailWrite( 0x4c, VC{0x04, 0x8d} );

	//Mystery setting difference.
	if( mysteryParameter ) {
		mailWrite( 0x4c, VC{0x62, 0x01} );
	} else {
		mailWrite( 0x4c, VC{0x62, 0x91} );
	}
}

void GCHD::configureCommonBlockB2()
{
	mailWrite( 0x4c, VC{0x0f, 0x89} );
	mailWrite( 0x4c, VC{0x58, 0xd8} );

	//Not sure if component or HDMI and component use this setting.
	switch (currentInputSettings_.getResolution()) {
		case Resolution::PAL:
		case Resolution::NTSC:
			mailWrite( 0x4c, VC{0x59, 0xd0} );
			break;
		default: //Everything else.
			mailWrite( 0x4c, VC{0x59, 0x20} );
			break;
	}
	mailWrite( 0x4c, VC{0x5a, 0x88} );

	switch(currentInputSettings_.getResolution()) {
		//Wondering if 2 parameters are just inexactly measured,
		//and variance is just noise.
		case Resolution::HD1080:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
				mailWrite( 0x4c, VC{0x5b, 0x8d} );
			} else { //1080p30 Component. 1080p60 HDMI
				mailWrite( 0x4c, VC{0x5b, 0x98} );
			}
			mailWrite( 0x4c, VC{0x5c, 0x88} );
			break;
		case Resolution::HD720:
			mailWrite( 0x4c, VC{0x5b, 0x8c} );
			mailWrite( 0x4c, VC{0x5c, 0x88} );
			break;
		case Resolution::PAL:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
				mailWrite( 0x4c, VC{0x5b, 0x9d} );
				mailWrite( 0x4c, VC{0x5c, 0x89} );
			} else {
				mailWrite( 0x4c, VC{0x5b, 0x99} );
				mailWrite( 0x4c, VC{0x5c, 0x88} );
			}
			break;
		case Resolution::NTSC:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
				mailWrite( 0x4c, VC{0x5b, 0x8e} );
				mailWrite( 0x4c, VC{0x5c, 0x89} );
			} else {
				mailWrite( 0x4c, VC{0x5b, 0x8a} );
				mailWrite( 0x4c, VC{0x5c, 0x88} );
			}
			break;
		default:
			throw runtime_error( "Current selected video mode is not a supported mode.");
			break;
	}

	mailWrite( 0x4c, VC{0x5e, 0x88} );
	mailWrite( 0x4c, VC{0x5f, 0x88} );
	mailWrite( 0x4c, VC{0x60, 0x88} );
	mailWrite( 0x4c, VC{0x61, 0x88} );
	mailWrite( 0x4c, VC{0x62, 0x88} );
	mailWrite( 0x4c, VC{0x63, 0x88} );
	mailWrite( 0x4c, VC{0x64, 0x88} );
	mailWrite( 0x4c, VC{0x65, 0x88} );

	uint8_t value;
	switch(currentInputSettings_.getResolution()) {
		case Resolution::HD1080:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //Component 1080i
				value = 0xfa;
			} else { //Componment 1080p
				value = 0xef;
			}
			break;
		case Resolution::HD720:
			value = 0xfb;
			break;
		case Resolution::PAL:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
				value = 0x39;
			} else {
				value = 0x3e;
			}
			break;
		case Resolution::NTSC:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
				value = 0x48;
			} else {
				value = 0x4d;
			}
			break;
		default:
			throw runtime_error( "Current selected video mode is not a supported mode.");
			break;
	}

	mailWrite( 0x4c, VC{0x5d, value} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xcd, 0x8b} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6b}
	mailWrite( 0x4c, VC{0x04, 0x8d} );

	uint8_t status;
	uint8_t mask;

	//This is a subroutine in original driver as it happens at a few lone times.
	{
		uint8_t testValue;
		do {
			mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
			testValue = mailRead( 0x33, 1 )[0] & 0x90;
		} while (testValue == 0);

		mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6e}
		mailWrite( 0x33, VC{0x99, 0x89, 0xfc} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6e}
		mailWrite( 0x33, VC{0x99, 0x89, 0xf3} );
		mailRead( 0x33, 1 ); //EXPECTED {0x7e}
		mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
		status=mailRead( 0x33, 1 )[0];
		mask=status & 0x10;
		mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x65)} );
		mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x64)} );
		mailWrite( 0x4c, VC{0x0d, 0xc8} );
	}

	status=mailRead( 0x33, 1 )[0];
	mask=value & 0x10;
	mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x65)} );
	mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x64)} );
	mailWrite( 0x4c, VC{0x0d, 0xc8} ); //This comes before
	//previous 2 statements
	//in some captures.

	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xc1, 0x89} );
	mailWrite( 0x4c, VC{0xc6, 0x8b} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0x61, 0x88} );

	mailWrite( 0x33, VC{0x10, 0x00, 0x33} );
	mailWrite( 0x33, VC{0x10, 0x01, 0xe3} );
	mailWrite( 0x33, VC{0x10, 0x02, 0x71} );
	mailWrite( 0x33, VC{0x10, 0x03, 0x72} );
	mailWrite( 0x33, VC{0x10, 0x01, 0x63} );
	mailWrite( 0x4c, VC{0x0f, 0x89} );

	switch(currentInputSettings_.getResolution()) {
		case Resolution::HD1080:
			if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
				mailWrite( 0x4c, VC{0x33, 0x08} );
				mailWrite( 0x4c, VC{0x34, 0xa5} );
			} else {
				mailWrite( 0x4c, VC{0x33, 0x88} );
				mailWrite( 0x4c, VC{0x34, 0x90} );
			}
			break;
		case Resolution::HD720:
			mailWrite( 0x4c, VC{0x33, 0x08} );
			mailWrite( 0x4c, VC{0x34, 0xa5} );
			break;
		case Resolution::PAL:
		case Resolution::NTSC:
			mailWrite( 0x4c, VC{0x33, 0x88} );
			mailWrite( 0x4c, VC{0x34, 0x90} );
			break;
		default:
			throw runtime_error( "Current selected video mode is not a supported mode.");
			break;
	}
	mailWrite( 0x4c, VC{0x35, 0x88} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xc5, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xa3} );
	mailRead( 0x33, 1 ); //EXPECTED {0x7f}
	mailWrite( 0x4c, VC{0x58, 0x9d} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6b}
	mailWrite( 0x4c, VC{0x04, 0x8d} );
	mailWrite( 0x4c, VC{0xe2, 0x6c} );
	mailWrite( 0x4c, VC{0xe3, 0x88} );
	mailWrite( 0x4c, VC{0xe4, 0x80} );
	mailWrite( 0x4c, VC{0xe0, 0x49} );
	mailWrite( 0x4c, VC{0xe1, 0x89} );
	mailWrite( 0x4c, VC{0x0f, 0x89} );
	mailWrite( 0x4c, VC{0x91, 0x88} );
	mailWrite( 0x4c, VC{0x92, 0x88} );
	mailWrite( 0x4c, VC{0x93, 0x89} );
	mailWrite( 0x4c, VC{0x94, 0xa9} );
	mailWrite( 0x4c, VC{0x95, 0xcb} );
	mailWrite( 0x4c, VC{0x96, 0xed} );
	mailWrite( 0x4c, VC{0x97, 0x0f} );
	mailWrite( 0x4c, VC{0x98, 0x8a} );
	mailWrite( 0x4c, VC{0x99, 0x53} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6b}
	mailWrite( 0x4c, VC{0x04, 0x8c} );
	mailWrite( 0x4c, VC{0x0f, 0x89} );
	mailWrite( 0x4c, VC{0x68, 0x89} );
	mailWrite( 0x4c, VC{0x6b, 0x88} );
	mailWrite( 0x4c, VC{0x6c, 0x88} );
	mailWrite( 0x4c, VC{0x6d, 0xf8} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xce, 0x8b} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6a}
	mailWrite( 0x4c, VC{0x04, 0x88} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xc1, 0x88} );
	mailWrite( 0x4c, VC{0xc6, 0x8b} );
}

void GCHD::configureCommonBlockB3()
{
	if (currentInputSettings_.getResolution() != Resolution::PAL) {
		mailWrite( 0x4c, VC{0x0f, 0x89} );
		mailWrite( 0x33, VC{0x99, 0x89, 0x5b} );
		mailRead( 0x33, 1 ); //EXPECTED {0x7c}
		mailWrite( 0x33, VC{0x99, 0x89, 0x5a} );
		mailRead( 0x33, 1 ); //EXPECTED {0x2a}
		mailWrite( 0x33, VC{0x99, 0x89, 0x59} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6c}

		mailWrite( 0x33, VC{0x99, 0x89, 0xc8} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6e}
		mailWrite( 0x33, VC{0x99, 0x89, 0xcf} );
		mailRead( 0x33, 1 ); //EXPECTED {0x76}
		mailWrite( 0x33, VC{0x99, 0x89, 0xce} );
		mailRead( 0x33, 1 ); //EXPECTED {0x6e};
		mailWrite( 0x4c, VC{0x0f, 0x88} );
	}
}

void GCHD::configureCommonBlockC()
{
	mailWrite( 0x33, VC{0xaa, 0xb8, 0x29, 0xf6} );
	mailWrite( 0x33, VC{0xa1, 0x08, 0x73} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0xa6, 0x33, 0xc0, 0x4d, 0xda, 0x67, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x7b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xf2, 0xb8, 0xcd, 0x3f, 0xb2, 0x25, 0x98, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x63} );
	mailRead( 0x33, 8 ); //EXPECTED {0xf7, 0x4e, 0xcd, 0x3c, 0x32, 0x25, 0x9a, 0x73}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x6b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xfc, 0x96, 0xb8, 0x9c, 0xe5, 0x69, 0x28, 0x28}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x53} );
	mailRead( 0x33, 8 ); //EXPECTED {0xef, 0x11, 0x80, 0x3f, 0xb2, 0x25, 0x19, 0xcb}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x5b} );
	mailRead( 0x33, 8 ); //EXPECTED {0x37, 0x99, 0xcd, 0x3e, 0xb3, 0x24, 0x99, 0x0a}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x43} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe7, 0x58, 0xcd, 0x3e, 0xb3, 0x24, 0x9a, 0x31}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x4b} );
	mailRead( 0x33, 8 ); //EXPECTED {0x66, 0x41, 0xbd, 0x07, 0x9f, 0x65, 0xc0, 0x27}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x33} );
	mailRead( 0x33, 8 ); //EXPECTED {0xa3, 0x59, 0x08, 0xb1, 0x93, 0x25, 0x98, 0x15}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x3b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x27, 0xb2, 0x39, 0x8e, 0x2b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x23} );
	mailRead( 0x33, 8 ); //EXPECTED {0xbe, 0x75, 0xe9, 0x3f, 0x76, 0xab, 0xb9, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x2b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0xc7, 0xcc, 0x3f, 0xb2, 0xd9, 0x98, 0x4e}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x13} );
	mailRead( 0x33, 8 ); //EXPECTED {0x8a, 0x3e, 0xad, 0x4b, 0xdd, 0x2f, 0xb8, 0x2b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x1b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xc6, 0x79, 0xec, 0x1f, 0xb2, 0x25, 0x98, 0xf6}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x03} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x4e, 0xf1, 0x26, 0xf4, 0x2a, 0x98, 0x01}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x0b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xc6, 0x79, 0xec, 0x1f, 0x92, 0x05, 0x99, 0xee}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xf3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe4, 0x5a, 0xea, 0xcb, 0xe3, 0xa0, 0x9c, 0x08}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xfb} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe4, 0x4b, 0xdf, 0xab, 0xa4, 0x22, 0x9e, 0x1a}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xe3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xf3, 0xf8, 0x6e, 0x18, 0xad, 0x35, 0xbb, 0x02}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xeb} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe1, 0x58, 0x4f, 0x3e, 0xb2, 0x25, 0xff, 0x08}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xd3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xea, 0x59, 0xdc, 0x3f, 0x92, 0x08, 0x14, 0x01}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xdb} );
	mailRead( 0x33, 8 ); //EXPECTED {0x46, 0x4d, 0x9d, 0xcf, 0xa4, 0x25, 0xbe, 0x77}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xc3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xa5, 0x59, 0x08, 0xb1, 0x93, 0x25, 0x98, 0x93}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xcb} );
	mailRead( 0x33, 8 ); //EXPECTED {0x6a, 0x53, 0x1c, 0xb5, 0x92, 0xc5, 0xb5, 0x1b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xb3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xf6, 0x67, 0x5a, 0x3f, 0x76, 0xab, 0xb9, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xbb} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x40, 0xcd, 0x22, 0xb2, 0x57, 0xc9, 0xdb}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xa3} );
	mailRead( 0x33, 8 ); //EXPECTED {0xf8, 0x79, 0xa2, 0x17, 0xe7, 0x25, 0x5c, 0x85}
	mailWrite( 0x33, VC{0xa1, 0x08, 0xab} );
	mailRead( 0x33, 8 ); //EXPECTED {0xc7, 0x59, 0xcc, 0x20, 0xb3, 0x38, 0x18, 0x13}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x93} );
	mailRead( 0x33, 8 ); //EXPECTED {0x97, 0x45, 0xda, 0x1f, 0xea, 0x09, 0xbd, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x9b} );
	mailRead( 0x33, 8 ); //EXPECTED {0x22, 0xd7, 0xed, 0x3f, 0xb2, 0xbb, 0x98, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x83} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x3f, 0xb2, 0x25, 0x98, 0x0b}
	mailWrite( 0x33, VC{0xa1, 0x08, 0x8b} );
	mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x3f, 0xb2, 0x25, 0x98, 0x04}
	mailWrite( 0x33, VC{0xaa, 0xb8, 0x29, 0xe7} );
}


